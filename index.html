<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>KSPé¢¨ ãƒ­ã‚±ãƒƒãƒˆã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚¿ãƒ¼ æœˆãƒ»ISSãƒŸãƒƒã‚·ãƒ§ãƒ³ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #87CEEB; touch-action: none; font-family: sans-serif; }
        canvas { display: block; }
        
        #ui { position: absolute; top: 10px; left: 10px; color: white; background: rgba(0,0,0,0.6); padding: 15px; border-radius: 8px; pointer-events: none; display: none; font-size: 14px; line-height: 1.5; z-index: 10; }
        #rocketNameDisplay { font-size: 18px; color: #ffd700; font-weight: bold; margin-bottom: 8px; border-bottom: 1px solid #777; padding-bottom: 5px; text-shadow: 1px 1px 2px black; }
        #backToBuildBtn { pointer-events: auto; background: #ff4757; color: white; border: none; padding: 5px 10px; font-size: 12px; border-radius: 4px; cursor: pointer; margin-top: 10px; width: 100%; font-weight: bold; }
        
        #controls { position: absolute; bottom: 15px; right: 10px; width: 60%; display: none; justify-content: flex-end; gap: 10px; padding: 0 10px; box-sizing: border-box; align-items: center; z-index: 10; }
        .btn { width: 60px; height: 60px; background: rgba(255, 255, 255, 0.8); border-radius: 50%; font-size: 11px; font-weight: bold; border: 2px solid #333; display: flex; justify-content: center; align-items: center; text-align: center; user-select: none; -webkit-user-select: none; cursor: pointer; box-shadow: 0 4px 6px rgba(0,0,0,0.3); pointer-events: auto; }
        .btn:active { background: rgba(200, 200, 200, 0.9); transform: translateY(2px); box-shadow: 0 1px 2px rgba(0,0,0,0.3); }
        #thrustBtn { width: 80px; height: 80px; background: rgba(255, 100, 100, 0.8); color: white; font-size: 15px; text-shadow: 1px 1px 2px black; }
        #parachuteBtn { background: rgba(100, 200, 255, 0.9); }
        #sasBtn { background: rgba(200, 200, 100, 0.9); }
        #stageBtn { background: rgba(255, 150, 50, 0.9); }
        
        #buildUI { position: absolute; top: 10px; right: 10px; background: rgba(255,255,255,0.9); padding: 15px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.2); display: flex; flex-direction: column; gap: 8px; width: 220px; z-index: 10; max-height: 90vh; overflow-y: auto; }
        #buildUI h3 { margin: 0 0 5px 0; text-align: center; color: #333; }
        .build-input { padding: 8px; font-size: 14px; border: 1px solid #ccc; border-radius: 4px; text-align: center; margin-bottom: 5px; }
        .build-btn { padding: 8px; font-size: 14px; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; background: #eee; border: 1px solid #ccc; transition: 0.2s; }
        .build-btn:hover { background: #ddd; }
        #addSatellite { background: #ffd700; border-color: #b8860b; }
        #addDecoupler { background: #ff7675; border-color: #d63031; color: white; }
        #launchBtn { background: #ff4757; color: white; border: none; padding: 15px; font-size: 16px; margin-top: 10px; box-shadow: 0 4px 0 #ff1e34; }
        #launchBtn:active { transform: translateY(4px); box-shadow: none; }
        #instruction { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #333; font-weight: bold; pointer-events: none; text-shadow: 1px 1px 2px white; }

        #gameOverUI { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 30px; border-radius: 10px; text-align: center; display: none; z-index: 20; }
        #gameOverUI h2 { color: #ff4757; margin-top: 0; }
        #retryBtn { background: #4CAF50; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer; margin-top: 15px; font-weight: bold; }

        #missionUI { position: absolute; top: 25%; width: 100%; text-align: center; color: #55ff55; font-size: 32px; font-weight: bold; text-shadow: 2px 2px 4px #000; display: none; pointer-events: none; z-index: 15; }

        #navMap { position: absolute; top: 10px; right: 10px; background: rgba(0, 20, 40, 0.8); border: 2px solid #555; border-radius: 50%; display: none; z-index: 10; width: 150px; height: 150px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }

        #joystickZone { position: absolute; bottom: 20px; left: 20px; width: 120px; height: 120px; background: rgba(255,255,255,0.2); border-radius: 50%; border: 2px solid #aaa; display: none; z-index: 20; touch-action: none; }
        #joystickKnob { position: absolute; top: 50%; left: 50%; width: 50px; height: 50px; background: rgba(255,255,255,0.9); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; box-shadow: 0 4px 6px rgba(0,0,0,0.3); }
    </style>
</head>
<body>
    <div id="ui">
        <div id="rocketNameDisplay"></div>
        <div>é«˜åº¦: <span id="alt">0</span> m</div>
        <div>é€Ÿåº¦: <span id="vel">0</span> m/s</div>
        <div>è§’åº¦: <span id="angleUI">90.0</span>Â°</div>
        <div>ç‡ƒæ–™: <span id="fuel">0</span> L</div>
        <div>æ¨åŠ›: <span id="thrustUI">0</span> kN</div>
        <button id="backToBuildBtn">â—€ çµ„ç«‹æ£Ÿã«æˆ»ã‚‹</button>
    </div>
    
    <div id="missionUI"></div>

    <canvas id="navMap" width="200" height="200"></canvas>

    <div id="joystickZone">
        <div id="joystickKnob"></div>
    </div>

    <div id="controls">
        <div id="autoBtn" class="btn">AUTO<br>OFF</div>
        <div id="sasBtn" class="btn">SAS<br>OFF</div>
        <div id="stageBtn" class="btn">âœ‚ï¸<br>åˆ†é›¢</div>
        <div id="parachuteBtn" class="btn">ğŸª‚<br>é–‹å‚˜</div>
        <div id="thrustBtn" class="btn">ğŸš€ æ¨åŠ›</div>
    </div>

    <div id="buildUI">
        <h3>ãƒ­ã‚±ãƒƒãƒˆçµ„ç«‹æ£Ÿ</h3>
        <input type="text" id="rocketNameInput" class="build-input" placeholder="æ©Ÿä½“å (ä»»æ„)" value="ã‚¢ãƒãƒ­å·">
        <button class="build-btn" id="addSatellite">ğŸ›° è¡›æ˜Ÿè¿½åŠ </button>
        <button class="build-btn" id="addCapsule">â–³ ã‚«ãƒ—ã‚»ãƒ«è¿½åŠ </button>
        <button class="build-btn" id="addTank">ğŸ›¢ ã‚¿ãƒ³ã‚¯è¿½åŠ </button>
        <button class="build-btn" id="addEngine">ğŸ”¥ ã‚¨ãƒ³ã‚¸ãƒ³è¿½åŠ </button>
        <button class="build-btn" id="addDecoupler">â¸ åˆ†é›¢ãƒªãƒ³ã‚°è¿½åŠ </button>
        <button class="build-btn" id="undoBuild">â†© 1ã¤æˆ»ã‚‹</button>
        <button class="build-btn" id="resetBuild" style="margin-top:10px;">ğŸ—‘ ãƒªã‚»ãƒƒãƒˆ</button>
        <button class="build-btn" id="launchBtn">ğŸš€ æ‰“ã¡ä¸Šã’ï¼</button>
    </div>
    <div id="instruction">ãƒ‘ãƒ¼ãƒ„ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ã€‚å‘¨å›è»Œé“ã«ä¹—ã£ã¦æœˆ(é«˜åº¦6000m)ã¨ISS(é«˜åº¦2000m)ã‚’ç›®æŒ‡ãã†ï¼</div>

    <div id="gameOverUI">
        <h2>å¤§ç ´ã—ã¾ã—ãŸğŸ’¥</h2>
        <p>ç€é™¸ãƒ»ãƒ‰ãƒƒã‚­ãƒ³ã‚°é€Ÿåº¦ãŒé€Ÿã™ããŸã‹ã€å§¿å‹¢ãŒå´©ã‚Œã¾ã—ãŸã€‚</p>
        <button id="retryBtn">çµ„ç«‹æ£Ÿã«æˆ»ã‚‹</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';

        // ------------ three / scene setup (unchanged mostly) --------------
        function createEarthMapTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#1e90ff';
            ctx.fillRect(0, 0, 1024, 512);
            
            ctx.fillStyle = '#228b22';
            for (let i = 0; i < 70; i++) {
                const x = Math.random() * 1024;
                const y = Math.random() * 512;
                const r = 20 + Math.random() * 70;
                ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill();
            }
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 1024, 40);
            ctx.fillRect(0, 472, 1024, 40);

            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 50000);
        camera.position.set(0, 10, 25);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.set(0, 5, 0);

        const world = new CANNON.World();
        world.gravity.set(0, 0, 0); 

        const planetRadius = 6000;
        const planetCenter = new CANNON.Vec3(0, -planetRadius, 0);
        const planetCenterThree = new THREE.Vector3(0, -planetRadius, 0);

        const light = new THREE.DirectionalLight(0xffffff, 1.8);
        light.position.set(20, 50, 30);
        scene.add(light);
        const fillLight = new THREE.DirectionalLight(0xaaccff, 0.5);
        fillLight.position.set(-20, 10, -20);
        scene.add(fillLight);
        scene.add(new THREE.AmbientLight(0x404040));

        const starsGeo = new THREE.BufferGeometry();
        const starsCount = 2000;
        const posArray = new Float32Array(starsCount * 3);
        for(let i = 0; i < starsCount * 3; i++) posArray[i] = (Math.random() - 0.5) * 25000;
        starsGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starsMat = new THREE.PointsMaterial({ size: 40, color: 0xffffff, transparent: true, opacity: 0 });
        const starMesh = new THREE.Points(starsGeo, starsMat);
        scene.add(starMesh);

        const groundMatCannon = new CANNON.Material();
        const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Sphere(planetRadius), material: groundMatCannon });
        groundBody.position.copy(planetCenter);
        world.addBody(groundBody);
        
        const earthMap = createEarthMapTexture();
        const groundMesh = new THREE.Mesh(new THREE.SphereGeometry(planetRadius, 64, 64), new THREE.MeshStandardMaterial({ map: earthMap, roughness: 0.8 }));
        groundMesh.position.copy(planetCenterThree);
        groundMesh.rotation.x = -Math.PI / 4; 
        scene.add(groundMesh);

        const padMesh = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 0.5, 32), new THREE.MeshStandardMaterial({color: 0x555555, roughness: 0.9}));
        padMesh.position.y = 0.25;
        scene.add(padMesh);

        const moonRadius = 300;
        const moonAlt = 6000;
        const moonAngle = Math.PI / 4; 
        const moonDist = planetRadius + moonAlt;
        const moonPos = new CANNON.Vec3(
            Math.sin(moonAngle) * moonDist,
            Math.cos(moonAngle) * moonDist - planetRadius,
            0
        );
        const moonBody = new CANNON.Body({ type: CANNON.Body.STATIC, shape: new CANNON.Sphere(moonRadius) });
        moonBody.position.copy(moonPos);
        world.addBody(moonBody);
        const moonMesh = new THREE.Mesh(new THREE.SphereGeometry(moonRadius, 32, 32), new THREE.MeshStandardMaterial({color: 0xdddddd, roughness: 0.9, metalness: 0.1}));
        moonMesh.position.copy(moonPos);
        scene.add(moonMesh);

        const issAlt = 2000;
        const issAngle = -Math.PI / 6; 
        const issDist = planetRadius + issAlt;
        const issPos = new CANNON.Vec3(
            Math.sin(issAngle) * issDist,
            Math.cos(issAngle) * issDist - planetRadius,
            0
        );
        const issBody = new CANNON.Body({ type: CANNON.Body.STATIC });
        const issQuat = new CANNON.Quaternion(); issQuat.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), Math.PI/2);
        issBody.addShape(new CANNON.Cylinder(4, 4, 30, 16), new CANNON.Vec3(0,0,0), issQuat); 
        issBody.addShape(new CANNON.Box(new CANNON.Vec3(25, 0.5, 10)), new CANNON.Vec3(0,0,0)); 
        issBody.position.copy(issPos);
        const issUp = new CANNON.Vec3(); issPos.vsub(planetCenter, issUp); issUp.normalize();
        const issAxis = new CANNON.Vec3(0, 1, 0).cross(issUp);
        const issAngleQuat = Math.acos(new CANNON.Vec3(0, 1, 0).dot(issUp));
        issBody.quaternion.setFromAxisAngle(issAxis, issAngleQuat);
        world.addBody(issBody);
        
        const issGroup = new THREE.Group();
        issGroup.position.copy(issPos);
        issGroup.quaternion.copy(issBody.quaternion);
        const issMain = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, 30, 16), new THREE.MeshStandardMaterial({color: 0xcccccc, metalness: 0.6}));
        issMain.rotation.z = Math.PI/2;
        const issPanels = new THREE.Mesh(new THREE.BoxGeometry(50, 0.5, 20), new THREE.MeshStandardMaterial({color: 0x1133bb, metalness: 0.8, roughness: 0.2}));
        issGroup.add(issMain, issPanels);
        scene.add(issGroup);

        // ------------ game state (unchanged fields) --------------
        let mode = 'build'; 
        let currentParts = []; 
        let isExploded = false;
        let satelliteDeployed = false; 
        
        const PART_DEFS = {
            satellite: { type: 'box', radius: 0.8, length: 1.0, mass: 0.5, fuel: 0, thrust: 0 },
            capsule:   { type: 'capsule', radius: 1, length: 2, mass: 1, fuel: 0, thrust: 0 },
            tank:      { type: 'cylinder', radius: 1, length: 4, mass: 4, fuel: 100, thrust: 0 },
            engine:    { type: 'cylinder', radius: 0.8, length: 1.5, mass: 1, fuel: 0, thrust: 350 },
            decoupler: { type: 'cylinder', radius: 1.05, length: 0.4, mass: 0.2, fuel: 0, thrust: 0 }
        };

        function createVerticalTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 1024;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#dddddd'; ctx.fillRect(0, 0, 1024, 1024);
            
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            const chars = text.split('');
            const fontSize = Math.min(120, 800 / (chars.length || 1)); 
            ctx.font = `bold ${fontSize}px sans-serif`;
            const startY = (1024 - (chars.length * fontSize)) / 2 + (fontSize / 2);
            
            for(let i = 0; i < chars.length; i++) {
                ctx.lineWidth = fontSize * 0.15; ctx.strokeStyle = '#000000';
                ctx.strokeText(chars[i], 512, startY + i * fontSize);
                ctx.fillStyle = '#ffffff'; ctx.fillText(chars[i], 512, startY + i * fontSize);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.colorSpace = THREE.SRGBColorSpace;
            return tex;
        }

        function createRealisticPartMesh(pName, isSatDeployed = false) {
            const group = new THREE.Group();
            
            if (pName === 'satellite') {
                const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.0, 1.4), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.9, roughness: 0.2 }));
                group.add(body);
                const panelsGroup = new THREE.Group();
                const solarMat = new THREE.MeshStandardMaterial({ color: 0x1133bb, metalness: 0.8, roughness: 0.2 });
                const panel1 = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.05, 1.2), solarMat); panel1.position.x = 2.55;
                const panel2 = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.05, 1.2), solarMat); panel2.position.x = -2.55;
                panelsGroup.add(panel1, panel2); group.add(panelsGroup);

                const fairingGroup = new THREE.Group();
                const fairingMat = new THREE.MeshStandardMaterial({ color: 0xeeeeee, metalness: 0.1, roughness: 0.8, side: THREE.DoubleSide });
                const fairingGeo = new THREE.CylinderGeometry(1.05, 1.05, 1.2, 16, 1, false, 0, Math.PI);
                const fairingL = new THREE.Mesh(fairingGeo, fairingMat);
                const fairingR = new THREE.Mesh(fairingGeo, fairingMat); fairingR.rotation.y = Math.PI;
                const noseGeo = new THREE.ConeGeometry(1.05, 1.0, 16, 1, false, 0, Math.PI);
                const noseL = new THREE.Mesh(noseGeo, fairingMat); noseL.position.y = 1.1; fairingL.add(noseL);
                const noseR = new THREE.Mesh(noseGeo, fairingMat); noseR.position.y = 1.1; fairingR.add(noseR);
                fairingGroup.add(fairingL, fairingR); group.add(fairingGroup);

                if (isSatDeployed) { panelsGroup.visible = true; fairingGroup.visible = false; } 
                else { panelsGroup.visible = false; fairingGroup.visible = true; }
            } 
            else if (pName === 'capsule') {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 32), new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.1, roughness: 0.5 }));
                const windowMesh = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.1, 16), new THREE.MeshStandardMaterial({ color: 0x111111, metalness: 0.9, roughness: 0.1 }));
                windowMesh.rotation.x = -Math.atan(0.5); windowMesh.position.set(0, 0, 0.55);
                const port = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 16), new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.7})); port.position.y = 1.0;
                const shield = new THREE.Mesh(new THREE.CylinderGeometry(1.02, 1.02, 0.2, 32), new THREE.MeshStandardMaterial({ color: 0x332222, metalness: 0.3, roughness: 0.9 })); shield.position.y = -0.9;
                const rcsMat = new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.8});
                const rcs1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.15), rcsMat); rcs1.position.set(0.7, -0.6, 0);
                const rcs2 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.15), rcsMat); rcs2.position.set(-0.7, -0.6, 0);
                group.add(cone, windowMesh, shield, port, rcs1, rcs2);
            } 
            else if (pName === 'tank') {
                const rName = document.getElementById('rocketNameInput').value || 'ç„¡åãƒ­ã‚±ãƒƒãƒˆ';
                const tankTex = createVerticalTextTexture(rName);
                const cyl = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 4, 32), new THREE.MeshStandardMaterial({ map: tankTex, metalness: 0.6, roughness: 0.4 }));
                const ribMat = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.8, roughness: 0.3 });
                const rib1 = new THREE.Mesh(new THREE.TorusGeometry(1.0, 0.04, 8, 32), ribMat); rib1.rotation.x = Math.PI / 2; rib1.position.y = 1.2;
                const rib2 = new THREE.Mesh(new THREE.TorusGeometry(1.0, 0.04, 8, 32), ribMat); rib2.rotation.x = Math.PI / 2; rib2.position.y = -1.2;
                group.add(cyl, rib1, rib2);
            } 
            else if (pName === 'engine') {
                const chamber = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32, 16), new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.5 })); chamber.position.y = 0.3;
                const nozzle = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.9, 1.1, 32, 1, true), new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9, roughness: 0.4, side: THREE.DoubleSide })); nozzle.position.y = -0.25;
                const manifold = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.08, 8, 32), new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8 })); manifold.rotation.x = Math.PI/2; manifold.position.y = 0.25;
                const pump = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), new THREE.MeshStandardMaterial({ color: 0x777777, metalness: 0.9, roughness: 0.3 })); pump.position.set(0.4, 0.4, 0);
                const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, 0.6), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9 })); pipe.position.set(0.4, 0.1, 0);
                group.add(chamber, nozzle, manifold, pump, pipe);
            } 
            else if (pName === 'decoupler') {
                const baseRing = new THREE.Mesh(new THREE.CylinderGeometry(1.05, 1.05, 0.4, 32), new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.5 }));
                const redLine = new THREE.Mesh(new THREE.CylinderGeometry(1.06, 1.06, 0.08, 32), new THREE.MeshStandardMaterial({ color: 0xff3333, metalness: 0.2, roughness: 0.5 }));
                group.add(baseRing, redLine);
            }
            return group;
        }

        const buildGroup = new THREE.Group();
        scene.add(buildGroup);

        function renderBuild() {
            while(buildGroup.children.length > 0) buildGroup.remove(buildGroup.children[0]); 
            let currentY = 15; 
            for (let i = 0; i < currentParts.length; i++) {
                const pName = currentParts[i];
                const pDef = PART_DEFS[pName];
                const meshGroup = createRealisticPartMesh(pName, false);
                meshGroup.position.y = currentY - (pDef.length / 2);
                currentY -= pDef.length; 
                buildGroup.add(meshGroup);
            }
        }

        document.getElementById('rocketNameInput').addEventListener('input', () => { if(mode === 'build') renderBuild(); });
        document.getElementById('addSatellite').onclick = () => { currentParts.push('satellite'); renderBuild(); };
        document.getElementById('addCapsule').onclick = () => { currentParts.push('capsule'); renderBuild(); };
        document.getElementById('addTank').onclick = () => { currentParts.push('tank'); renderBuild(); };
        document.getElementById('addEngine').onclick = () => { currentParts.push('engine'); renderBuild(); };
        document.getElementById('addDecoupler').onclick = () => { currentParts.push('decoupler'); renderBuild(); };
        document.getElementById('undoBuild').onclick = () => { if (currentParts.length > 0) { currentParts.pop(); renderBuild(); } };
        document.getElementById('resetBuild').onclick = () => { currentParts = []; renderBuild(); };

        // ------------ physics / rocket state --------------
        let rocketBody, rocketMesh, flames = [];
        let rocketStats = { fuel: 0, maxThrust: 0, totalMass: 0, lowestY: 0 };
        const state = { thrust: false, joyX: 0, joyY: 0 };
        let parachuteDeployed = false;
        let parachuteMesh;
        let sasEnabled = false;
        let autoMode = 'OFF'; // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã®çŠ¶æ…‹ ('OFF', 'MOON', 'ISS')
        
        let activeParts = []; 
        let debrisList = []; 

        // ------------ AUDIO: Web Audio API (ãƒ—ãƒ­ã‚°ãƒ©ãƒ ç”Ÿæˆ) --------------
        let audioCtx = null;
        let engineOsc = null, engineGain = null, engineFilter = null, engineLFO = null;
        let engineInitialized = false;

        function initAudioIfNeeded() {
            if (engineInitialized) return;
            try {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } catch (e) {
                console.warn('AudioContext not supported', e);
                return;
            }

            // ã‚¨ãƒ³ã‚¸ãƒ³ã®æŒç¶šãƒã‚¤ã‚ºï¼ˆsaw + filter + LFO ã§ã‚´ã‚©ãƒ¼ã‚’ä½œã‚‹ï¼‰
            engineOsc = audioCtx.createOscillator();
            engineOsc.type = 'sawtooth';
            engineFilter = audioCtx.createBiquadFilter();
            engineFilter.type = 'lowpass';
            engineFilter.frequency.value = 800;

            engineGain = audioCtx.createGain();
            engineGain.gain.value = 0.0;

            // LFO ã§ãƒ•ã‚£ãƒ«ã‚¿ã‚’æºã‚‰ã™ï¼ˆç‚ã®æºã‚‰ãã«ç›¸å½“ï¼‰
            engineLFO = audioCtx.createOscillator();
            engineLFO.type = 'sine';
            const lfoGain = audioCtx.createGain();
            lfoGain.gain.value = 200;
            engineLFO.connect(lfoGain);
            lfoGain.connect(engineFilter.frequency);

            engineOsc.connect(engineFilter);
            engineFilter.connect(engineGain);
            engineGain.connect(audioCtx.destination);

            engineOsc.start();
            engineLFO.start();

            engineInitialized = true;
        }

        // çˆ†ç™ºéŸ³ï¼ˆçŸ­ã„ãƒã‚¤ã‚ºãƒãƒ¼ã‚¹ãƒˆã‚’ç”Ÿæˆï¼‰
        function playExplosionSound() {
            if (!audioCtx) return;
            const len = audioCtx.sampleRate * 0.6;
            const buffer = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            // å¼·ã‚ã®ä½å‘¨ãƒã‚¤ã‚ºã«ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ã‚’ã‹ã‘ã‚‹
            for (let i = 0; i < len; i++) {
                const t = i / len;
                const env = Math.pow(1 - t, 3);
                data[i] = (Math.random() * 2 - 1) * env * (0.6 + Math.random() * 0.4);
            }
            const src = audioCtx.createBufferSource();
            src.buffer = buffer;
            const lp = audioCtx.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = 800;
            const gain = audioCtx.createGain(); gain.gain.value = 0.8;
            src.connect(lp); lp.connect(gain); gain.connect(audioCtx.destination);
            src.start();
        }

        // åˆ†é›¢éŸ³ï¼ˆçŸ­ã„é«˜åŸŸã®ãƒ‘ãƒ«ã‚¹ï¼‰
        function playDecoupleSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = 'square';
            osc.frequency.value = 1200 + Math.random() * 800;
            g.gain.value = 0.0001;
            osc.connect(g); g.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            g.gain.setValueAtTime(0.0001, now);
            g.gain.exponentialRampToValueAtTime(0.6, now + 0.005);
            g.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        // ã‚¨ãƒ³ã‚¸ãƒ³ã‚²ã‚¤ãƒ³ã‚’æ›´æ–°ï¼ˆ0..1ï¼‰
        function setEngineLevel(level) {
            if (!engineInitialized) return;
            const t = audioCtx.currentTime;
            engineGain.gain.cancelScheduledValues(t);
            engineGain.gain.setTargetAtTime(level * 0.8, t, 0.05);
            // ãƒ•ã‚£ãƒ«ã‚¿ã‚‚å°‘ã—ä¸Šã’ã¦é‡ä½éŸ³ã®å¹…ã‚’å¤‰ãˆã‚‹
            engineFilter.frequency.setTargetAtTime(400 + level * 3000, t, 0.05);
            engineLFO.frequency.setTargetAtTime(1 + level * 4, t, 0.2);
        }

        // ------------ PARTICLES: ç…™ãƒ»ç«èŠ±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ --------------
        const particleGroup = new THREE.Group();
        scene.add(particleGroup);
        const smokePool = [];
        const sparkPool = [];
        const MAX_SMOKE = 120;
        const MAX_SPARKS = 80;

        // ãƒãƒ†ãƒªã‚¢ãƒ«ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã€ãƒ©ã‚¤ãƒˆè² è·ï¼‰
        const smokeMat = new THREE.MeshBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5, depthWrite: false });
        const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 1.0, depthWrite: false });

        for (let i = 0; i < MAX_SMOKE; i++) {
            const m = new THREE.Mesh(new THREE.SphereGeometry(0.4, 6, 6), smokeMat.clone());
            m.visible = false; particleGroup.add(m); smokePool.push({ mesh: m, vel: new THREE.Vector3(), life: 0 });
        }
        for (let i = 0; i < MAX_SPARKS; i++) {
            const m = new THREE.Mesh(new THREE.SphereGeometry(0.12, 6, 6), sparkMat.clone());
            m.visible = false; particleGroup.add(m); sparkPool.push({ mesh: m, vel: new THREE.Vector3(), life: 0 });
        }

        function spawnEngineParticles(worldPos, worldDir, intensity) {
            // smoke
            for (let i = 0; i < Math.min(3, Math.ceil(intensity * 3)); i++) {
                const p = smokePool.find(x => x.life <= 0);
                if (!p) break;
                p.mesh.visible = true;
                p.mesh.position.copy(worldPos);
                // slight random offset
                p.mesh.position.x += (Math.random() - 0.5) * 0.2;
                p.mesh.position.z += (Math.random() - 0.5) * 0.2;
                const speed = 1 + Math.random() * 2;
                p.vel.copy(worldDir).multiplyScalar(-speed);
                p.vel.x += (Math.random() - 0.5) * 0.8;
                p.vel.y += 0.5 + Math.random() * 1.0;
                p.life = 1.0 + Math.random() * 1.2;
                p.mesh.scale.setScalar(0.6 + Math.random() * 0.8);
                p.mesh.material.opacity = 0.6;
            }
            // sparks
            for (let i = 0; i < Math.min(4, Math.ceil(intensity * 6)); i++) {
                const p = sparkPool.find(x => x.life <= 0);
                if (!p) break;
                p.mesh.visible = true;
                p.mesh.position.copy(worldPos);
                p.mesh.position.x += (Math.random() - 0.5) * 0.1;
                p.mesh.position.z += (Math.random() - 0.5) * 0.1;
                const speed = 6 + Math.random() * 6;
                p.vel.set((Math.random()-0.5)*2, -Math.random()*2, (Math.random()-0.5)*2);
                p.life = 0.25 + Math.random()*0.35;
                p.mesh.scale.setScalar(0.06 + Math.random()*0.08);
                p.mesh.material.opacity = 1.0;
            }
        }

        function updateParticles(dt) {
            smokePool.forEach(p => {
                if (p.life > 0) {
                    p.life -= dt;
                    p.mesh.position.addScaledVector(p.vel, dt);
                    p.mesh.material.opacity = Math.max(0, p.life / 1.6);
                    const s = 1 + (1 - p.life) * 1.4;
                    p.mesh.scale.setScalar(s);
                    if (p.life <= 0) { p.mesh.visible = false; }
                }
            });
            sparkPool.forEach(p => {
                if (p.life > 0) {
                    p.life -= dt;
                    p.mesh.position.addScaledVector(p.vel, dt);
                    p.mesh.material.opacity = Math.max(0, p.life / 0.6);
                    p.mesh.scale.setScalar(Math.max(0.01, p.life * 0.6));
                    if (p.life <= 0) { p.mesh.visible = false; }
                }
            });
        }

        // ------------ build / launch / physics body creation --------------
        document.getElementById('launchBtn').onclick = () => {
            if(currentParts.length === 0) return alert("ãƒ‘ãƒ¼ãƒ„ã‚’è¿½åŠ ã—ã¦ãã ã•ã„ï¼");
            
            // audio åˆæœŸåŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œãŒã‚ã‚‹ã®ã§å†ç”Ÿå¯èƒ½ã«ï¼‰
            initAudioIfNeeded();

            document.getElementById('rocketNameDisplay').innerText = document.getElementById('rocketNameInput').value || "ç„¡åãƒ­ã‚±ãƒƒãƒˆ";

            mode = 'flight';
            isExploded = false; parachuteDeployed = false; sasEnabled = false; satelliteDeployed = false;
            
            // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆåˆæœŸåŒ–
            autoMode = 'OFF';
            document.getElementById('autoBtn').innerHTML = "AUTO<br>OFF";
            document.getElementById('autoBtn').style.background = "rgba(255, 255, 255, 0.8)";
            
            document.getElementById('parachuteBtn').style.opacity = '1.0';
            document.getElementById('sasBtn').innerHTML = "SAS<br>OFF";
            document.getElementById('sasBtn').style.background = "rgba(200, 200, 100, 0.9)";
            
            document.getElementById('buildUI').style.display = 'none';
            document.getElementById('instruction').style.display = 'none';
            document.getElementById('controls').style.display = 'flex';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('gameOverUI').style.display = 'none';
            document.getElementById('missionUI').style.display = 'none';
            document.getElementById('navMap').style.display = 'block'; 
            document.getElementById('joystickZone').style.display = 'block'; 
            
            buildGroup.visible = false; 
            
            activeParts = [];
            let currentY = 0;
            for (let i = 0; i < currentParts.length; i++) {
                const name = currentParts[i];
                const pDef = PART_DEFS[name];
                const cy = currentY - (pDef.length / 2);
                activeParts.push({ ...pDef, name: name, originalY: cy });
                currentY -= pDef.length;
            }

            // ç™ºå°„å°ã«åˆã‚ã›ã‚‹ãŸã‚ã« alignToPad=true
            buildPhysicsBody(new CANNON.Vec3(0, 0.25, 0), new CANNON.Vec3(), new CANNON.Quaternion(), new CANNON.Vec3(), true);
            
            camera.position.set(10, 10, 25);
            camera.up.set(0, 1, 0); 
            controls.target.copy(rocketMesh.position);
        };

        // buildPhysicsBody ã« alignToPad ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’è¿½åŠ ï¼ˆç™ºå°„å°ã¸ã®æ­£ã—ã„é…ç½®ã‚’æ‹…ä¿ï¼‰
        function buildPhysicsBody(pos, vel, quat, angVel, alignToPad=false) {
            if(rocketBody) world.removeBody(rocketBody);
            if(rocketMesh) scene.remove(rocketMesh);

            rocketMesh = new THREE.Group();
            flames = [];
            rocketStats = { fuel: 0, maxThrust: 0, totalMass: 0, lowestY: 0 };
            
            let cgY = 0;
            activeParts.forEach(p => { rocketStats.totalMass += p.mass; cgY += p.originalY * p.mass; });
            cgY /= rocketStats.totalMass || 1; 

            rocketBody = new CANNON.Body({ mass: rocketStats.totalMass, type: CANNON.Body.DYNAMIC, angularDamping: sasEnabled ? 0.99 : 0.4 }); 
            
            let topYLocal = -Infinity; let lowestYLocal = Infinity;

            activeParts.forEach(p => {
                const offsetY = p.originalY - cgY; 
                rocketStats.fuel += p.fuel; rocketStats.maxThrust += p.thrust;

                if(offsetY + (p.length / 2) > topYLocal) topYLocal = offsetY + (p.length / 2);
                if(offsetY - (p.length / 2) < lowestYLocal) lowestYLocal = offsetY - (p.length / 2);

                let shape; const shapeQuat = new CANNON.Quaternion();
                if (p.type === 'box') { shape = new CANNON.Box(new CANNON.Vec3(p.radius, p.length / 2, p.radius)); } 
                else {
                    shape = p.type === 'capsule' ? new CANNON.Cylinder(0.1, p.radius, p.length, 12) : new CANNON.Cylinder(p.radius, p.radius, p.length, 12);
                    shapeQuat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                }
                rocketBody.addShape(shape, new CANNON.Vec3(0, offsetY, 0), shapeQuat);

                const meshGroup = createRealisticPartMesh(p.name, satelliteDeployed);
                meshGroup.position.y = offsetY;
                rocketMesh.add(meshGroup);
                
                if (p.thrust > 0) {
                    const flameMesh = new THREE.Mesh(new THREE.ConeGeometry(0.8, 2.5, 8), new THREE.MeshBasicMaterial({ color: 0xffaa00, transparent: true, opacity: 0.9 }));
                    flameMesh.position.y = offsetY - (p.length / 2) - 1.2; 
                    flameMesh.rotation.x = Math.PI; flameMesh.visible = false;
                    rocketMesh.add(flameMesh); flames.push(flameMesh);
                }
            });

            rocketStats.lowestY = lowestYLocal;

            const paraGeo = new THREE.SphereGeometry(3, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            parachuteMesh = new THREE.Mesh(paraGeo, new THREE.MeshBasicMaterial({ color: 0xff4444, side: THREE.DoubleSide }));
            parachuteMesh.position.y = topYLocal + 1.0; 
            parachuteMesh.visible = parachuteDeployed;
            rocketMesh.add(parachuteMesh);
            
            // ç™ºå°„å°ã«åˆã‚ã›ã‚‹ãƒ­ã‚¸ãƒƒã‚¯:
            if (alignToPad) {
                // pos.y ã‚’ pad ã®ä¸Šé¢ï¼ˆä¾‹: 0.25ï¼‰ã¨ã—ã¦ã€ãƒ­ãƒ¼ã‚«ãƒ«æœ€ä½ç‚¹ãŒ pad ã®ä¸Šã«æ¥ã‚‹ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆ
                rocketBody.position.set(pos.x, pos.y - lowestYLocal + 0.0, pos.z);
            } else {
                rocketBody.position.copy(pos);
            }
            rocketBody.velocity.copy(vel); rocketBody.quaternion.copy(quat); rocketBody.angularVelocity.copy(angVel);

            world.addBody(rocketBody); scene.add(rocketMesh);
        }

        function deployFairingDebris(partsList, oldPos, oldVel, oldQuat, oldAngVel) {
            let currentCgY = 0, currentTotalMass = 0;
            partsList.forEach(p => { currentTotalMass += p.mass; currentCgY += p.originalY * p.mass; });
            currentCgY /= currentTotalMass;

            partsList.forEach(p => {
                if (p.name === 'satellite') {
                    const offsetY = p.originalY - currentCgY;
                    const satLocalPos = new CANNON.Vec3(0, offsetY, 0);
                    const satWorldPos = oldQuat.vmult(satLocalPos).vadd(oldPos);

                    for(let i=0; i<2; i++) {
                        const dBody = new CANNON.Body({ mass: 0.1, type: CANNON.Body.DYNAMIC });
                        dBody.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.6, 1.05)));
                        const offsetLocal = new CANNON.Vec3((i===0 ? 0.6 : -0.6), 0, 0);
                        const offsetWorld = oldQuat.vmult(offsetLocal);
                        dBody.position.copy(satWorldPos).vadd(offsetWorld);
                        
                        const pushVel = oldQuat.vmult(new CANNON.Vec3((i===0 ? 4 : -4), 0, 0));
                        dBody.velocity.copy(oldVel).vadd(pushVel);
                        dBody.quaternion.copy(oldQuat);
                        dBody.angularVelocity.copy(oldAngVel); dBody.angularVelocity.x += (Math.random()-0.5)*5;

                        const fairingGeo = new THREE.CylinderGeometry(1.05, 1.05, 1.2, 16, 1, false, 0, Math.PI);
                        const fairingMat = new THREE.MeshStandardMaterial({color: 0xeeeeee, metalness: 0.1, roughness: 0.8, side: THREE.DoubleSide});
                        const mesh = new THREE.Mesh(fairingGeo, fairingMat);
                        if (i===1) mesh.rotation.y = Math.PI;
                        const noseGeo = new THREE.ConeGeometry(1.05, 1.0, 16, 1, false, 0, Math.PI);
                        const nose = new THREE.Mesh(noseGeo, fairingMat); nose.position.y = 1.1; mesh.add(nose);

                        const dGroup = new THREE.Group(); dGroup.add(mesh);
                        world.addBody(dBody); scene.add(dGroup);
                        debrisList.push({ body: dBody, mesh: dGroup });
                    }
                }
            });
        }

        document.getElementById('stageBtn').onclick = () => {
            if (mode !== 'flight' || isExploded) return;
            let decoupleIdx = -1;
            for (let i = activeParts.length - 1; i >= 0; i--) { if (activeParts[i].name === 'decoupler') { decoupleIdx = i; break; } }

            if (decoupleIdx <= 0) {
                if (!satelliteDeployed && activeParts.some(p => p.name === 'satellite')) {
                    satelliteDeployed = true;
                    deployFairingDebris(activeParts, rocketBody.position, rocketBody.velocity, rocketBody.quaternion, rocketBody.angularVelocity);
                    buildPhysicsBody(rocketBody.position, rocketBody.velocity, rocketBody.quaternion, rocketBody.angularVelocity);
                    // éŸ³ã‚’é³´ã‚‰ã™
                    initAudioIfNeeded();
                    playDecoupleSound();
                }
                return; 
            }

            const keptParts = activeParts.slice(0, decoupleIdx);
            const droppedParts = activeParts.slice(decoupleIdx);
            activeParts = keptParts;

            const hasMoreDecouplers = keptParts.some(p => p.name === 'decoupler');
            const hasSatellite = keptParts.some(p => p.name === 'satellite');
            
            let deployNow = false;
            if (!hasMoreDecouplers && !satelliteDeployed && hasSatellite) { satelliteDeployed = true; deployNow = true; }

            const oldPos = rocketBody.position.clone(); const oldVel = rocketBody.velocity.clone();
            const oldQuat = rocketBody.quaternion.clone(); const oldAngVel = rocketBody.angularVelocity.clone();

            let oldCgY = 0, oldTotalMass = 0;
            [...keptParts, ...droppedParts].forEach(p => { oldTotalMass += p.mass; oldCgY += p.originalY * p.mass; });
            oldCgY /= oldTotalMass;
            let newCgY = 0, newTotalMass = 0;
            keptParts.forEach(p => { newTotalMass += p.mass; newCgY += p.originalY * p.mass; });
            newCgY /= newTotalMass;

            const cgShiftLocal = new CANNON.Vec3(0, newCgY - oldCgY, 0);
            const cgShiftWorld = oldQuat.vmult(cgShiftLocal);
            const newPos = new CANNON.Vec3(); oldPos.vadd(cgShiftWorld, newPos);

            buildPhysicsBody(newPos, oldVel, oldQuat, oldAngVel);
            createDebris(droppedParts, oldCgY, oldPos, oldVel, oldQuat, oldAngVel);

            if (deployNow) {
                deployFairingDebris(keptParts, newPos, oldVel, oldQuat, oldAngVel);
                initAudioIfNeeded();
                playDecoupleSound();
            }
        };

        function createDebris(droppedParts, oldCgY, oldPos, oldVel, oldQuat, oldAngVel) {
            let dMass = 0, dCgY = 0;
            droppedParts.forEach(p => { dMass += p.mass; dCgY += p.originalY * p.mass; });
            dCgY /= dMass;

            const cgShiftLocal = new CANNON.Vec3(0, dCgY - oldCgY, 0);
            const cgShiftWorld = oldQuat.vmult(cgShiftLocal);
            const dPos = new CANNON.Vec3(); oldPos.vadd(cgShiftWorld, dPos);

            const dBody = new CANNON.Body({ mass: dMass, type: CANNON.Body.DYNAMIC });
            const dMeshGroup = new THREE.Group();

            droppedParts.forEach(p => {
                const offsetY = p.originalY - dCgY;
                let shape; const shapeQuat = new CANNON.Quaternion();
                if (p.type === 'box') { shape = new CANNON.Box(new CANNON.Vec3(p.radius, p.length / 2, p.radius)); } 
                else { shape = p.type === 'capsule' ? new CANNON.Cylinder(0.1, p.radius, p.length, 12) : new CANNON.Cylinder(p.radius, p.radius, p.length, 12); shapeQuat.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); }
                dBody.addShape(shape, new CANNON.Vec3(0, offsetY, 0), shapeQuat);
                const meshGroup = createRealisticPartMesh(p.name, satelliteDeployed);
                meshGroup.position.y = offsetY; dMeshGroup.add(meshGroup);
            });

            dBody.position.copy(dPos); dBody.velocity.copy(oldVel);
            const retroWorld = oldQuat.vmult(new CANNON.Vec3(0, -2, 0));
            dBody.velocity.vadd(retroWorld, dBody.velocity);
            dBody.quaternion.copy(oldQuat); dBody.angularVelocity.copy(oldAngVel); dBody.angularVelocity.x += (Math.random()-0.5)*1.0; 

            world.addBody(dBody); scene.add(dMeshGroup); debrisList.push({ body: dBody, mesh: dMeshGroup });
        }

        document.getElementById('parachuteBtn').onclick = () => {
            if (mode === 'flight' && !isExploded && !parachuteDeployed) { parachuteDeployed = true; if(parachuteMesh) parachuteMesh.visible = true; document.getElementById('parachuteBtn').style.opacity = '0.5'; }
        };
        document.getElementById('sasBtn').onclick = () => {
            if (mode !== 'flight' || isExploded) return;
            sasEnabled = !sasEnabled;
            document.getElementById('sasBtn').innerHTML = sasEnabled ? "SAS<br>ON" : "SAS<br>OFF";
            document.getElementById('sasBtn').style.background = sasEnabled ? "rgba(100, 255, 100, 0.9)" : "rgba(200, 200, 100, 0.9)";
            if (rocketBody) rocketBody.angularDamping = (sasEnabled || autoMode !== 'OFF') ? 0.99 : 0.4;
        };

        // è¿½åŠ ï¼šã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆãƒœã‚¿ãƒ³ã®å‡¦ç†ï¼ˆå¼·åŒ–ï¼‰
        document.getElementById('autoBtn').onclick = () => {
            if (mode !== 'flight' || isExploded) return;
            if (autoMode === 'OFF') autoMode = 'MOON';
            else if (autoMode === 'MOON') autoMode = 'ISS';
            else autoMode = 'OFF';

            const btn = document.getElementById('autoBtn');
            if (autoMode === 'OFF') {
                btn.innerHTML = "AUTO<br>OFF";
                btn.style.background = "rgba(255, 255, 255, 0.8)";
            } else if (autoMode === 'MOON') {
                btn.innerHTML = "AUTO<br>ğŸŒ•æœˆ";
                btn.style.background = "rgba(200, 200, 255, 0.9)";
            } else {
                btn.innerHTML = "AUTO<br>ğŸ›°ISS";
                btn.style.background = "rgba(255, 200, 150, 0.9)";
            }
            if (rocketBody) rocketBody.angularDamping = (sasEnabled || autoMode !== 'OFF') ? 0.99 : 0.4;
        };

        let explosionParticles = [];
        function createExplosion(pos) {
            for(let i=0; i<50; i++){
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6, 8, 8), new THREE.MeshBasicMaterial({ color: [0xff0000, 0xff8800, 0x555555][Math.floor(Math.random() * 3)], transparent: true }));
                mesh.position.copy(pos); scene.add(mesh);
                explosionParticles.push({ mesh: mesh, velocity: new THREE.Vector3((Math.random()-0.5)*30, Math.random()*20, (Math.random()-0.5)*30), life: 1.0 + Math.random() * 0.5 });
            }
            // éŸ³
            initAudioIfNeeded();
            playExplosionSound();
        }

        function returnToVAB() {
            mode = 'build'; isExploded = false; satelliteDeployed = false; autoMode = 'OFF';
            document.getElementById('buildUI').style.display = 'flex'; document.getElementById('instruction').style.display = 'block'; document.getElementById('controls').style.display = 'none'; document.getElementById('ui').style.display = 'none'; document.getElementById('gameOverUI').style.display = 'none'; document.getElementById('missionUI').style.display = 'none'; document.getElementById('navMap').style.display = 'none';
            document.getElementById('joystickZone').style.display = 'none'; 
            
            if(rocketBody) world.removeBody(rocketBody); if(rocketMesh) scene.remove(rocketMesh);
            explosionParticles.forEach(p => scene.remove(p.mesh)); explosionParticles = [];
            debrisList.forEach(d => { world.removeBody(d.body); scene.remove(d.mesh); }); debrisList = [];
            buildGroup.visible = true; camera.position.set(0, 10, 25); camera.up.set(0, 1, 0); controls.target.set(0, 5, 0); scene.background.setHSL(0.55, 0.8, 0.5); starsMat.opacity = 0; 
        }

        document.getElementById('retryBtn').onclick = returnToVAB; document.getElementById('backToBuildBtn').onclick = returnToVAB;

        const setupButton = (id, key) => {
            const btn = document.getElementById(id); if(!btn) return;
            btn.addEventListener('pointerdown', (e) => { e.preventDefault(); state[key] = true; }); btn.addEventListener('pointerup', (e) => { e.preventDefault(); state[key] = false; }); btn.addEventListener('pointerleave', (e) => { e.preventDefault(); state[key] = false; });
        };
        setupButton('thrustBtn', 'thrust');

        // ã‚¹ãƒ©ã‚¹ãƒˆãƒœã‚¿ãƒ³ã¯åˆå›ã‚¿ãƒƒãƒ—ã§ AudioContext ã‚’èµ·å‹•ã™ã‚‹ã‚ˆã†ã«
        document.getElementById('thrustBtn').addEventListener('pointerdown', (e) => { initAudioIfNeeded(); });

        const joyZone = document.getElementById('joystickZone');
        const joyKnob = document.getElementById('joystickKnob');
        let joyActive = false;
        let joyCenterX = 0;
        let joyCenterY = 0;

        joyZone.addEventListener('pointerdown', (e) => {
            e.preventDefault();
            joyActive = true;
            const rect = joyZone.getBoundingClientRect();
            joyCenterX = rect.left + rect.width / 2;
            joyCenterY = rect.top + rect.height / 2;
            updateJoystick(e);
        });

        window.addEventListener('pointermove', (e) => {
            if (!joyActive) return;
            e.preventDefault();
            updateJoystick(e);
        });

        const resetJoystick = () => {
            joyActive = false;
            state.joyX = 0;
            state.joyY = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
        };
        window.addEventListener('pointerup', resetJoystick);
        window.addEventListener('pointercancel', resetJoystick);

        function updateJoystick(e) {
            let dx = e.clientX - joyCenterX;
            let dy = e.clientY - joyCenterY;
            const maxDist = 40; 
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > maxDist) {
                dx = (dx / dist) * maxDist;
                dy = (dy / dist) * maxDist;
            }
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            state.joyX = dx / maxDist; 
            state.joyY = dy / maxDist; 
        }

        const uiAlt = document.getElementById('alt'); const uiVel = document.getElementById('vel'); const uiFuel = document.getElementById('fuel'); const uiThrust = document.getElementById('thrustUI'); const missionUI = document.getElementById('missionUI'); const uiAngle = document.getElementById('angleUI');

        const applySphericalGravity = (body) => {
            const dir = new CANNON.Vec3();
            planetCenter.vsub(body.position, dir);
            const dist = dir.length();
            if (dist < 0.1) return;
            dir.normalize();
            const g = 9.81 * Math.pow(planetRadius / dist, 2);
            body.applyForce(dir.scale(body.mass * g), body.position);
        };

        function updateNavMap() {
            const canvas = document.getElementById('navMap');
            if (canvas.style.display === 'none') return;
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, 200, 200);
            
            const cx = 100; 
            const cy = 100; 
            const scale = 100 / 14000; 

            ctx.fillStyle = '#1e90ff';
            ctx.beginPath();
            ctx.arc(cx, cy, planetRadius * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#dddddd';
            const mx = cx + moonBody.position.x * scale;
            const my = cy - (moonBody.position.y - planetCenter.y) * scale;
            ctx.beginPath();
            ctx.arc(mx, my, moonRadius * scale * 2, 0, Math.PI * 2); 
            ctx.fill();

            ctx.fillStyle = '#ffaa00';
            const ix = cx + issBody.position.x * scale;
            const iy = cy - (issBody.position.y - planetCenter.y) * scale;
            ctx.fillRect(ix - 3, iy - 3, 6, 6);

            ctx.fillStyle = '#ff0000';
            if (rocketBody) {
                const rx = cx + rocketBody.position.x * scale;
                const ry = cy - (rocketBody.position.y - planetCenter.y) * scale;
                ctx.beginPath();
                ctx.arc(rx, ry, 3, 0, Math.PI * 2);
                ctx.fill();

                const worldUp = rocketBody.quaternion.vmult(new CANNON.Vec3(0, 1, 0));
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(rx, ry);
                ctx.lineTo(rx + worldUp.x * 12, ry - worldUp.y * 12);
                ctx.stroke();
            }
        }

        const timeStep = 1 / 60; let lastCallTime = performance.now();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() / 1000; const dt = time - lastCallTime; lastCallTime = time;
            controls.update();

            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                let p = explosionParticles[i]; p.life -= dt;
                if (p.life <= 0) { scene.remove(p.mesh); explosionParticles.splice(i, 1); } 
                else { p.mesh.position.addScaledVector(p.velocity, dt); p.mesh.material.opacity = p.life; p.mesh.scale.setScalar(p.life * 1.5); }
            }

            debrisList.forEach(d => { d.mesh.position.copy(d.body.position); d.mesh.quaternion.copy(d.body.quaternion); });

            if (mode === 'build') { renderer.render(scene, camera); return; }

            if (!isExploded && rocketBody) {
                applySphericalGravity(rocketBody);
                debrisList.forEach(d => applySphericalGravity(d.body));

                // SAS / auto mode ã®è§’é€Ÿåº¦æŠ‘åˆ¶ï¼ˆæ—¢å­˜ï¼‰
                if (sasEnabled || autoMode !== 'OFF') rocketBody.angularVelocity.scale(0.4, rocketBody.angularVelocity); 

                // è¿½åŠ ï¼šã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆæ©Ÿèƒ½ï¼ˆã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®æŒ‡å‘ãƒ»å¼·åŒ–ï¼‰
                if (autoMode !== 'OFF') {
                    const targetPos = autoMode === 'MOON' ? moonBody.position : issBody.position;
                    const targetDir = new CANNON.Vec3();
                    targetPos.vsub(rocketBody.position, targetDir);
                    targetDir.normalize();

                    const currentDir = rocketBody.quaternion.vmult(new CANNON.Vec3(0, 1, 0));
                    const crossNode = currentDir.cross(targetDir);
                    const dotProd = currentDir.dot(targetDir);
                    const angleDiff = Math.acos(Math.max(-1, Math.min(1, dotProd)));

                    if (angleDiff > 0.01 && crossNode.lengthSquared() > 0.0001) {
                        crossNode.normalize();
                        // å¼·åŒ–ï¼šè§’åº¦å·®ã¨é€Ÿåº¦ã«å¿œã˜ã¦ãƒˆãƒ«ã‚¯ã‚’ä¸ãˆã‚‹ï¼ˆã‚ˆã‚Šç©æ¥µçš„ã«å‘ãï¼‰
                        const speed = rocketBody.velocity.length();
                        const alignTorque = rocketStats.totalMass * (120 + Math.min(200, speed * 2)) * angleDiff;
                        rocketBody.applyTorque(crossNode.scale(alignTorque));
                    }
                }

                // è¿½åŠ ï¼šSAS ãŒ ON ã®ã¨ãã€é«˜é€Ÿãªã‚‰ã€Œé€²è¡Œæ–¹å‘ï¼ˆãƒ—ãƒ­ã‚°ãƒ¬ãƒ¼ãƒ‰ï¼‰ã€ã‚’ç¶­æŒã™ã‚‹ã‚ˆã†ã«ãƒˆãƒ«ã‚¯ã‚’ä¸ãˆã‚‹
                if (sasEnabled) {
                    const speed = rocketBody.velocity.length();
                    if (speed > 2) { // ã‚ã‚‹ç¨‹åº¦é€Ÿåº¦ãŒã‚ã‚‹å ´åˆã®ã¿ prograde ã‚’ç¶­æŒ
                        const prograde = new CANNON.Vec3();
                        prograde.copy(rocketBody.velocity);
                        if (prograde.length() > 0.001) {
                            prograde.normalize();
                            const currentDir = rocketBody.quaternion.vmult(new CANNON.Vec3(0, 1, 0)); // æ©Ÿé¦–ãƒ™ã‚¯ãƒˆãƒ«
                            const crossNode = currentDir.cross(prograde);
                            const dotProd = currentDir.dot(prograde);
                            const angleDiff = Math.acos(Math.max(-1, Math.min(1, dotProd)));
                            if (angleDiff > 0.005 && crossNode.lengthSquared() > 0.00001) {
                                crossNode.normalize();
                                const sasAlignTorque = rocketStats.totalMass * 80 * angleDiff * Math.min(1.0, speed / 60);
                                rocketBody.applyTorque(crossNode.scale(sasAlignTorque));
                            }
                        }
                    }
                }

                let currentThrust = 0;
                if (state.thrust && rocketStats.fuel > 0) {
                    const fuelConsumptionRate = rocketStats.maxThrust * 0.01; 
                    rocketStats.fuel -= dt * fuelConsumptionRate; if (rocketStats.fuel < 0) rocketStats.fuel = 0;
                    // thrust ãƒ¬ãƒ™ãƒ«ã‚’ 0..1 ã«æ­£è¦åŒ–ï¼ˆè¦–è¦šãƒ»éŸ³ãƒ»ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åˆ¶å¾¡ç”¨ï¼‰
                    const thrustLevel = Math.min(1, rocketStats.fuel / (fuelConsumptionRate * 10) + 0.5);
                    currentThrust = rocketStats.maxThrust * (0.5 + 0.5 * (rocketStats.fuel / Math.max(0.1, rocketStats.fuel + dt*fuelConsumptionRate)));
                    rocketBody.applyLocalForce(new CANNON.Vec3(0, currentThrust, 0), new CANNON.Vec3(0, rocketStats.lowestY, 0));
                    flames.forEach(f => { f.visible = true; f.scale.setScalar(0.7 + Math.random() * 0.6); });

                    // éŸ³é‡åˆ¶å¾¡ï¼ˆã‚¨ãƒ³ã‚¸ãƒ³ï¼‰
                    setEngineLevel(thrustLevel);

                    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åå‡ºï¼ˆå„ãƒ•ãƒ¬ãƒ¼ãƒ ã€å™´å°„å£ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰ä½ç½®ã‚’å–ã‚‹ï¼‰
                    for (let i = 0; i < flames.length; i++) {
                        const f = flames[i];
                        if (!f.visible) continue;
                        const worldPos = new THREE.Vector3(); f.getWorldPosition(worldPos);
                        // worldDir = ãƒã‚ºãƒ«ã®ã€Œä¸‹ã€æ–¹å‘ï¼ˆãƒ­ãƒ¼ã‚«ãƒ« -Y ãŒå™´å°„æ–¹å‘ã®ã¯ãšï¼‰
                        const nozzleDir = new THREE.Vector3(0, -1, 0).applyQuaternion(f.getWorldQuaternion(new THREE.Quaternion()));
                        spawnEngineParticles(worldPos, nozzleDir, 0.6 + Math.random() * 0.8);
                    }
                } else { 
                    flames.forEach(f => f.visible = false);
                    // ã‚¨ãƒ³ã‚¸ãƒ³éŸ³ã‚’ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
                    setEngineLevel(0);
                }

                // å¤‰æ›´ï¼šãƒãƒ¼ãƒãƒ£ãƒ«ãƒ‘ãƒƒãƒ‰ã®æ„Ÿåº¦ï¼ˆãƒˆãƒ«ã‚¯ï¼‰ã‚’15ã‹ã‚‰60ã¸å¤§å¹…ã«ä¸Šæ˜‡
                const torqueAmt = rocketStats.totalMass * 60; 
                if (state.joyX !== 0 || state.joyY !== 0) {
                    const localTorque = new CANNON.Vec3(state.joyY * torqueAmt, 0, -state.joyX * torqueAmt);
                    rocketBody.applyTorque(rocketBody.quaternion.vmult(localTorque));
                }

                const distToCenter = rocketBody.position.distanceTo(planetCenter);
                const altitude = distToCenter - planetRadius;
                
                const gravityUp = new CANNON.Vec3();
                rocketBody.position.vsub(planetCenter, gravityUp);
                gravityUp.normalize();
                camera.up.copy(new THREE.Vector3(gravityUp.x, gravityUp.y, gravityUp.z));

                // è¿½åŠ ï¼šãƒ”ãƒƒãƒè§’åº¦ã®è¨ˆç®—ã¨è¡¨ç¤º
                const worldUp = rocketBody.quaternion.vmult(new CANNON.Vec3(0, 1, 0));
                const pitchAngle = Math.asin(Math.max(-1, Math.min(1, worldUp.dot(gravityUp)))) * (180 / Math.PI);
                uiAngle.innerText = pitchAngle.toFixed(1);

                const speedVec = rocketBody.velocity; const speed = speedVec.length();
                const airDensity = Math.max(0, 1 - (altitude / 5000)); 
                
                let dot = 1; if (speed > 0.1) dot = worldUp.dot(new CANNON.Vec3(speedVec.x/speed, speedVec.y/speed, speedVec.z/speed));
                const crossSection = rocketStats.totalMass * (1.0 - Math.abs(dot) * 0.6); 
                let dragMultiplier = 0.01;

                if (parachuteDeployed) {
                    dragMultiplier = 0.5; 
                    if (speed > 1) {
                        const vNormX = speedVec.x / speed, vNormY = speedVec.y / speed, vNormZ = speedVec.z / speed;
                        rocketBody.applyTorque(new CANNON.Vec3(-(worldUp.y * vNormZ - worldUp.z * vNormY) * speed * 2, -(worldUp.z * vNormX - worldUp.x * vNormZ) * speed * 2, -(worldUp.x * vNormY - worldUp.y * vNormX) * speed * 2));
                    }
                } else if (speed > 5 && airDensity > 0.1 && !sasEnabled && autoMode === 'OFF') {
                    const vNormX = speedVec.x / speed, vNormY = speedVec.y / speed, vNormZ = speedVec.z / speed;
                    rocketBody.applyTorque(new CANNON.Vec3(-(worldUp.y * vNormZ - worldUp.z * vNormY) * speed * airDensity * rocketStats.totalMass * 0.02, -(worldUp.z * vNormX - worldUp.x * vNormZ) * speed * airDensity * rocketStats.totalMass * 0.02, -(worldUp.x * vNormY - worldUp.y * vNormX) * speed * airDensity * rocketStats.totalMass * 0.02));
                }

                const dragCoeff = dragMultiplier * airDensity * crossSection; 
                rocketBody.applyForce(new CANNON.Vec3(-speedVec.x * speed * dragCoeff, -speedVec.y * speed * dragCoeff, -speedVec.z * speed * dragCoeff), rocketBody.position);

                world.step(timeStep, dt, 3);
                rocketMesh.position.copy(rocketBody.position); rocketMesh.quaternion.copy(rocketBody.quaternion);
                controls.target.lerp(rocketMesh.position, 0.15);

                updateNavMap();

                scene.background.setHSL(0.55, 0.8, 0.5 * Math.max(0, 1 - (altitude / 8000)));
                starsMat.opacity = Math.max(0, Math.min(1, (altitude - 1000) / 3000));

                uiAlt.innerText = Math.max(0, altitude).toFixed(0); uiVel.innerText = speed.toFixed(1); uiFuel.innerText = Math.max(0, rocketStats.fuel).toFixed(0); uiThrust.innerText = (currentThrust / 10).toFixed(0);

                const distMoon = rocketBody.position.distanceTo(moonBody.position);
                const distISS = rocketBody.position.distanceTo(issBody.position);
                
                let missionText = "";
                if (distMoon < moonRadius + Math.abs(rocketStats.lowestY) + 2.0 && speed < 5) {
                    missionText = "ğŸŒ• æœˆé¢ç€é™¸æˆåŠŸï¼<br><span style='font-size:16px; color:white;'>ãƒ‘ãƒ©ã‚·ãƒ¥ãƒ¼ãƒˆã‚’é–‹ã„ã¦åœ°çƒã«å¸°é‚„ã—ã‚ˆã†ï¼</span>";
                } else if (distISS < 25 && speed < 5) {
                    missionText = "ğŸ›° ISSãƒ‰ãƒƒã‚­ãƒ³ã‚°æˆåŠŸï¼";
                }
                if (missionText !== "") { missionUI.innerHTML = missionText; missionUI.style.display = 'block'; } 
                else { missionUI.style.display = 'none'; }

                const hitGround = altitude < Math.abs(rocketStats.lowestY) + 0.6;
                const hitMoon = distMoon < moonRadius + Math.abs(rocketStats.lowestY) + 0.5;
                const hitISS = distISS < 20; 
                const isHardImpact = speed > (parachuteDeployed ? 15 : 8);

                if ((hitGround || hitMoon || hitISS) && isHardImpact) {
                    isExploded = true; createExplosion(rocketMesh.position); scene.remove(rocketMesh);
                    document.getElementById('gameOverUI').style.display = 'block'; document.getElementById('controls').style.display = 'none'; missionUI.style.display = 'none'; document.getElementById('joystickZone').style.display = 'none';
                }
            }

            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
            updateParticles((performance.now()/1000 - time) || 0.016);
            renderer.render(scene, camera);
        }

        animate();
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>